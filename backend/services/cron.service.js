const cron = require('node-cron');
const connection = require('../config/db.config');

class CronService {
  static startJobs() {
    // Ch·∫°y v√†o 00:01 m·ªói ng√†y
    cron.schedule('1 0 * * *', async () => {
      console.log('üïê [CRON] Starting daily tasks...');
      try {
        // 1. Apply pending work shift updates
        const WorkShiftModel = require('../models/workshift.model');
        await WorkShiftModel.applyPendingUpdates();
        
        // 2. T·ª± ƒë·ªông checkout nh·ªØng timesheet qu√™n checkout
        const DailyTimesheetModel = require('../models/dailyTimesheet.model');
        await DailyTimesheetModel.autoCheckoutForgottenTimesheets();
        
        // 3. T·∫°o timesheet m·ªõi cho ng√†y h√¥m nay
        await this.generateDailyTimesheets();
        
        console.log('‚úÖ [CRON] Daily tasks completed');
      } catch (error) {
        console.error('‚ùå [CRON] Error in daily tasks:', error);
      }
    });

    console.log('‚úÖ Cron jobs scheduled: Daily tasks at 00:01 (shift updates + auto checkout + timesheet generation)');
    
    // Uncomment ƒë·ªÉ test ngay khi server start
    // this.generateDailyTimesheets();
  }

  static async generateDailyTimesheets(targetDate = null) {
    const workDate = targetDate || new Date().toISOString().split('T')[0];

    try {
      // 1. L·∫•y t·∫•t c·∫£ nh√¢n vi√™n active c√≥ department
      const [employees] = await connection.query(`
        SELECT e.employee_id, e.department_id, e.status
        FROM EMPLOYEE e
        WHERE e.status = 'active' AND e.department_id IS NOT NULL
      `);

      if (employees.length === 0) {
        console.log('‚ÑπÔ∏è [CRON] No active employees found');
        return { created: 0, skipped: 0, errors: 0 };
      }

      console.log(`üìä [CRON] Processing ${employees.length} employees for ${workDate}`);

      let created = 0;
      let skipped = 0;
      let errors = 0;

      // 2. L·∫•y work shifts cho t·∫•t c·∫£ departments
      const [workShifts] = await connection.query(`
        SELECT shift_id, department_id FROM WORK_SHIFT
      `);

      const shiftMap = {};
      workShifts.forEach(shift => {
        shiftMap[shift.department_id] = shift.shift_id;
      });

      // 3. Process t·ª´ng nh√¢n vi√™n
      for (const emp of employees) {
        try {
          const shiftId = shiftMap[emp.department_id];

          if (!shiftId) {
            console.warn(`‚ö†Ô∏è [CRON] No work shift for department ${emp.department_id}`);
            skipped++;
            continue;
          }

          // Ki·ªÉm tra ƒë√£ t·ªìn t·∫°i ch∆∞a
          const [existing] = await connection.query(
            'SELECT 1 FROM DAILY_TIMESHEET WHERE employee_id = ? AND work_date = ?',
            [emp.employee_id, workDate]
          );

          if (existing.length > 0) {
            skipped++;
            continue;
          }

          // T·∫°o timesheet m·ªõi
          await connection.query(`
            INSERT INTO DAILY_TIMESHEET 
            (employee_id, work_date, shift_id, check_in_time, check_out_time, 
             minutes_late, minutes_early, notes, adjusted_by_employee_id)
            VALUES (?, ?, ?, NULL, NULL, 0, 0, 'Auto-generated by system', NULL)
          `, [emp.employee_id, workDate, shiftId]);

          created++;
        } catch (err) {
          console.error(`‚ùå Error creating timesheet for ${emp.employee_id}:`, err.message);
          errors++;
        }
      }

      console.log(`‚úÖ [CRON] Created: ${created}, Skipped: ${skipped}, Errors: ${errors}`);

      return { created, skipped, errors };
    } catch (error) {
      console.error('‚ùå [CRON] Fatal error:', error);
      throw error;
    }
  }

  // Manual trigger
  static async manualTrigger(date) {
    const targetDate = date || new Date().toISOString().split('T')[0];
    console.log(`üîß [MANUAL] Generating timesheets for ${targetDate}`);
    return this.generateDailyTimesheets(targetDate);
  }
}

module.exports = CronService;
